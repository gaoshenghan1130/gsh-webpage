---
name: Best Advancer Role Matching for SJTU SRC Team
intro: A role matching system for the best advancer in SJTU SRC Robocup.
desc: The second version of role matching system for the best advancer in SJTU SRC Robocup, implementing Ferrari's method to solve quartic equations for estimating chasing time.
link: https://github.com/sjtu-src/Falcon2023/tree/dev
tags: ["Qt", "C++", "Algrithm"]
image: /static/images/rolematch.png
---

## Overview

This module estimates the **time required for each robot to reach the ball**, under simplified physical assumptions.  
It is mainly used to determine the **best attacker** in a multi-robot system.

Original Chinese version of this document can be found at [SRC Wiki](https://sjtu-src.github.io/Wiki/chapter_software/sub_chapter_skill/bestPlayer/).

---

## Assumptions

1. The ball moves at a **constant velocity**.
2. Each robot starts from its **current position and velocity**, accelerating toward the ball at its **maximum acceleration** `a_max`.

---

## Algorithm Purpose

The main goals are:

- Estimate **chasing time** for each robot
- Avoid unstable switching between attackers when times are close
- Choose a **best attacker** based on a scoring system  
  that considers both _shortest time_ and _duration of being optimal_

---

## Function Overview

### `ourBestChaser(const CVisionModule* pVision)`

Determines the **best robot** to chase the ball.

| Step | Logic                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------- |
| 1    | If any robot is within `disForDisJudge`, choose the closest one directly.                         |
| 2    | Otherwise, compute **chasing time** for each robot using `findTime()`.                            |
| 3    | Select the robot with the **minimum estimated time**.                                             |
| 4    | Introduce a **stabilization delay** (`waitHowManyCycleBeforeChange`) to avoid frequent switching. |

---

### `findTime(p, v, p0, v0, a_max)`

Computes the **minimum time** for a robot at position `p` with velocity `v`  
to catch a ball at `p0` with velocity `v0`, given the robot's max acceleration `a_max`.

#### Mathematical Model

After coordinate transformation (ball velocity â†’ x-axis):

<MathBlock
  expression={String.raw`
\begin{cases}
p_y + v_y t + \frac{1}{2} a_y t^2 = 0 \\
p_x + v_x t + \frac{1}{2} a_x t^2 = v_0 t \\
|a| = a_{\max}
\end{cases}
`}
/>

This forms a **quartic equation** in `t`, solved via **Ferrari's method**.  
The smallest positive real root is the estimated chasing time.

---

### Ferrari() and sqrtn_complex()

These implement the **Ferrari algorithm** to find all four roots of the quartic equation,  
using complex arithmetic to handle non-real intermediate results.

---

<InlineCode>transCoordinateSys()</InlineCode>

Transforms coordinates such that the **ball's velocity aligns with the x-axis**, simplifying equations:

```cpp
point_complex *= conj(ball_v_complex / abs(ball_v_complex));
```
